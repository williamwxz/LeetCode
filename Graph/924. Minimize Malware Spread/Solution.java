class Solution {
    // union find
    // for the set with only one intial malware
    // take the biggest set
    // 1. if there multiple same size of set, return the min index
    // 2. if the biggest set has multiple malware, return the min index
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int m = graph[0].length;
        int[] parents = new int[n];
        int[] sizes = new int[n];
        for (int i=0; i<n;i++){
            parents[i] = i;
            sizes[i]=1;
        }
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                if (i!=j && graph[i][j]==1){
                    union(parents, sizes, i, j);
                }
            }
        }
        int index=n;
        int[] malware = new int[n];
        for (int init:initial){
            index= Math.min(index, init);
            malware[find(parents, init)]++;
        }
        //find the biggest set with only one malware
        //if all clusters have more than 2 malwares, just return the min of initial
        int max=0;
        for (int init:initial){
            int p = find(parents, init);
            if (malware[p]!=1){
                continue;
            }
            if (sizes[p]>max){
                index = init;
                max = sizes[p];
            }else if (sizes[p]==max){
                index=Math.min(index, init);
            }
        }
        return index;
    }
    private int find(int[] parents, int node){
        while (node!=parents[node]){
            parents[node] = parents[parents[node]];
            node = parents[node];
        }
        return node;
    }
    private boolean union(int[] parents, int[] sizes, int node1, int node2){
        int p1 = find(parents, node1);
        int p2 = find(parents, node2);
        if (p1==p2){
            return false;
        }
        parents[p2] = p1;
        sizes[p1] += sizes[p2];
        sizes[p2] = 0;
        return true;
    }
}